<!doctype html>
<html lang="en">
<head>
  <script src="data/J5.js"></script>
  <script src="data/J4.js"></script>
  <script src="data/J41.js"></script>
  <script src="data/J42.js"></script>
  <script src="data/J3.js"></script>
  <script src="data/J31.js"></script>
  <script src="data/J32.js"></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kanjiru – JLPT Quiz</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #0b0d12;
      --panel: #121722;
      --muted: #7781a1;
      --text: #e8ecf6;
      --brand: #7c5cff;
      --brand-2: #2dd4bf;
      --good: #22c55e; /* green */
      --bad: #ef4444; /* red */
      --ring: 0 0 0 3px rgba(124,92,255,.25);
      --shadow: 0 10px 30px rgba(0,0,0,.35), 0 2px 8px rgba(0,0,0,.3);
      --radius: 16px;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      background: radial-gradient(1200px 800px at 20% -10%, rgba(124,92,255,.25), transparent 60%),
                  radial-gradient(1200px 800px at 90% 0%, rgba(45,212,191,.20), transparent 65%),
                  var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .wrap{ max-width:800px; margin:0 auto; padding:28px 20px 64px }

    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:18px;
    }
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;  /* so it doesn't block clicks */
      background: radial-gradient(1200px 800px at 20% -10%, rgba(124,92,255,.25), transparent 60%),
                  radial-gradient(1200px 800px at 90% 0%, rgba(45,212,191,.20), transparent 65%),
                  var(--bg);
      background-repeat: no-repeat;
      background-attachment: fixed;
    }
    .brand{ display:flex; align-items:center; gap:12px; font-weight:800; letter-spacing:.2px; }
    .logo{
      width:36px; height:36px; border-radius:12px; display:grid; place-items:center;
      background: linear-gradient(135deg, var(--brand), var(--brand-2));
      box-shadow: var(--shadow);
      font-weight:800; color:white;
    }
    .panel{ background:linear-gradient(180deg, rgba(255,255,255,.03), transparent 60%), var(--panel);
      border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); box-shadow:var(--shadow);
    }
    .setup-panel,
    .quiz-panel,
    .pool-panel {
      width: 100%;
      max-width: 700px;   /* you can adjust this (600–800px works well) */
      margin: 0 auto 20px auto;  /* center + spacing below */
      visible: false;
    }
    .pool-panel {
      opacity: 0;
    }

    .q-word {
      font-weight: 800;
      color: var(--brand-2); /* teal accent or choose brand */
    }

    .q-subword {
      font-weight: 700;
      color: var(--brand); /* purple accent */
      opacity: 0.9;
    }
    .card{ padding:20px 20px }
    .title{ font-size:22px; font-weight:800; margin:2px 0 8px }
    .muted{ color:var(--muted); font-size:14px }

    .controls{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:10px }
    .controls .row{ display:flex; flex-direction:column; gap:8px }
    label{ font-size:14px; color:var(--muted) }
    input[type="number"], select{
      width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.1);
      background:#0e1320; color:var(--text); outline:none; transition:.2s border, .2s box-shadow;
    }
    input[type="number"]:focus, select:focus{ border-color: rgba(124,92,255,.7); box-shadow: var(--ring) }

    .segmented {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      background: transparent;
      border: none;
      padding: 0;
    }

    .segmented button {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.1);
      background: #0e1320;
      color: var(--muted);
      font-weight: 600;
      cursor: pointer;
      transition: .15s background, .15s color;
      font-size:12px;
    }

    .segmented button.active {
      background: linear-gradient(180deg, rgba(124,92,255,.3), rgba(124,92,255,.2));
      color: var(--text);
      border-color: rgba(124,92,255,.4);
    }

    .actions{ display:flex; gap:10px; margin-top:14px; flex-wrap:wrap }
    .btn{
      padding:12px 16px; border-radius:12px; border:0; font-weight:700; letter-spacing:.25px; cursor:pointer;
      transition: transform .06s ease, box-shadow .2s ease, background .15s ease; white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px) }
    .btn.primary{
      background: linear-gradient(180deg, rgba(124,92,255,.9), rgba(124,92,255,.8)); color:white; box-shadow: var(--shadow);
    }
    .btn.secondary{ background:#0e1320; color:var(--text); border:1px solid rgba(255,255,255,.12) }

    .quiz{
      padding:24px 22px 26px; display:none;
    }
    .quiz.active{ display:block }
    .q-top{ display:flex; align-items:center; justify-content:space-between; gap:10px }
    .pill{ font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); color:var(--muted) }

    .progress{ width:100%; height:10px; background:#0e1320; border:1px solid rgba(255,255,255,.08); border-radius:999px; margin:12px 0 18px; overflow:hidden }
    .bar{ height:100%; width:0%; background: linear-gradient(90deg, var(--brand), var(--brand-2)); transition: width .35s ease }

    .q-card{ padding:18px; border-radius:14px; border:1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.02) }
    .question{ font-size:20px; font-weight:800; margin:0 0 8px }
    .sub{ font-size:14px; color:var(--muted); margin-bottom:14px }

    .choices{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px }
    @media (max-width: 700px){ .choices{ grid-template-columns: 1fr } }

    .choice{
      padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:#0e1320;
      text-align:left; font-weight:600; color:var(--text); cursor:pointer; transition: .2s border, .2s transform, .2s background;
    }
    .choice:hover{ border-color: rgba(124,92,255,.6) }
    .choice.correct{ border-color: rgba(34,197,94,.9); background: rgba(34,197,94,.08) }
    .choice.wrong{ border-color: rgba(239,68,68,.8); background: rgba(239,68,68,.08) }

    .feedback{ margin-top:8px; font-weight:700 }
    .feedback.good{ color: var(--good) }
    .feedback.bad{ color: var(--bad) }

    .footer-actions{ display:flex; justify-content:space-between; align-items:center; margin-top:16px }

    .results{ display:none; padding:22px }
    .results.active{ display:block }
    .score{
      font-size:48px; font-weight:800; line-height:1; background: linear-gradient(180deg, #fff, #cfe2ff); -webkit-background-clip:text; color:transparent;
    }
    .result-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; margin-top:16px }
    @media (max-width: 700px){ .result-grid{ grid-template-columns: 1fr } }
    .mini{ padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,.1); background:#0e1320 }

    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.15); background:#0e1320; color:var(--muted) }

    .hint{ font-size:12px; color:var(--muted) }

    .pool-table {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .pool-item {
      padding: 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.1);
      cursor: pointer;
      transition: .2s background, .2s border;
      font-size: 10px;
    }

    .pool-item.disabled {
      opacity: 0.4;
      background: rgba(255,255,255,0.08);
      border-color: rgba(239,68,68,0.5); /* red hint */
    }

  </style>
</head>
<body>

  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">字</div>
        <div>
          <div class="title" style="margin:0">Kanjiru - JLPT Practice</div>
          <div class="muted">Vocab & readings practice - <i>by Diptip</i></div>
        </div>
      </div>
    </header>

    <section class="panel card setup-panel">
        <div class="title">Setup</div>
        <div class="muted">Pick a level, mode, and how many questions you want. Press <b>Start</b>.</div>

        <div class="controls">
          <div class="row">
            <label for="level">JLPT Level</label>
            <select id="level">
              <option value="5">N5 (261 words)</option>
              <option value="4">N4 (381 words)</option>
              <option value="41">&nbsp;&nbsp;&nbsp;N4.1 (200 words)</option>
              <option value="42">&nbsp;&nbsp;&nbsp;N4.2 (181 words)</option>
              <option value="3">N3 (400 words)</option>
              <option value="31">&nbsp;&nbsp;&nbsp;N3.1 (200 words)</option>
              <option value="32">&nbsp;&nbsp;&nbsp;N3.2 (200 words)</option>
            </select>
          </div>

          <div class="row">
            <label for="num">Questions per session</label>
            <input id="num" type="number" min="1" max="100" step="1" value="10">
          </div>

          <div class="row" style="grid-column: 1 / -1;">
            <label for="mode">Mode</label>
            <div class="segmented" id="mode">
              <button data-mode="word" class="active">Kanji</button>
              <button data-mode="meaning">Meaning</button>
              <button data-mode="reading">Reading</button>
              <button data-mode="learning">Study</button>
            </div>
          </div>

          <div class="row learning-range" style="grid-column: 1 / -1; display: none;">
            <label>Lesson</label>
            <select id="learnGroup"></select>
          </div>

        </div>


        <div class="actions">
          <button class="btn primary" id="startBtn">Start</button>
          <button class="btn secondary" id="resetBtn">Reset</button>
          <div class="hint" id="hint"></div>
        </div>
    </section>

    <section class="panel quiz-panel">
        <div class="quiz" id="quiz">
          <div class="q-top">
            <div class="pill" id="modePill">Mode: Meaning</div>
            <div class="muted" id="counter">0 / 0</div>
          </div>
          <div class="progress"><div class="bar" id="bar"></div></div>

          <div class="q-card">
            <div class="question" id="qText">Press Start to begin</div>
            <div class="sub" id="qSub"></div>
            <div class="choices" id="choices"></div>
            <div class="feedback" id="feedback"></div>
            <div class="footer-actions">
              <div></div>
              <button class="btn primary" id="nextBtn" disabled>Next</button>
            </div>
          </div>
        </div>
        <div class="results" id="results">
          <div class="title">Session results</div>
          <div class="score" id="score">—</div>
          <div class="result-grid">
            <div class="mini" id="breakdown">—</div>
            <div class="mini" id="summary">—</div>
          </div>
          <div class="actions" style="margin-top:18px">
            <button class="btn primary" id="againBtn">Run it again</button>
            <button class="btn secondary" id="reviewBtn">Review mistakes</button>
          </div>
        </div>
    </section>


    <section class="panel card pool-panel">
      <div class="title" style="display:flex; justify-content:space-between; align-items:center;">
        Pool Selection (optional)
        <button id="togglePool" class="btn secondary">Show</button>
      </div>
      <div class="muted">Click a word to disable/enable it. Disabled = will not appear in questions.</div>

      <div id="poolTable" class="pool-table">
        <!-- JS will fill in these words -->
      </div>
    </section>

  </div>

  <script>
    // ========= Data Loading & Parsing =========
    const available_levels = [5,41,42,4,31,32];
    const available_modes = ["word", "meaning", "reading","learning"];
    const questionOrder = {
      word:    ["reading", "meaning"],   // show word, ask reading → meaning
      meaning: ["word", "reading"],     // show meaning, ask kanji → reading
      reading: ["word", "meaning"]      // show reading, ask kanji → meaning
    };


    function textLines(str){
      return (str||"").replace(/\r/g, "").split("\n").map(s=>s.trim()).filter(Boolean);
    }

    function parseJ(level){
      const s = window["J"+level];
      if(!s) return [];
      const out = [];
      for(const line of textLines(s)){
        const bits = line.split(/\s+/);
        if(bits.length < 3) continue;
        const word = bits[0];
        const reading = bits[1];
        const meaning = bits.slice(2).join(" ");
        out.push({word, reading, meaning});
      }
      return out;
    }

    const JN = {};
    let dataReady = false;
    function loadAll(){
      for(const L of available_levels){
        JN[L] = parseJ(L);
      }
      dataReady = available_levels.some(L => (JN[L] && JN[L].length));
    }

    function buildPool() {
      const pool = JN[state.level] || [];
      return pool.filter(q => !state.excluded.has(q.word + '|' + q.reading));
    }

    function renderPool() {
      const poolDiv = document.getElementById('poolTable');
      poolDiv.innerHTML = "";

      const pool = JN[state.level] || [];
      pool.forEach(q => {
        const key = q.word + "|" + q.reading;
        const div = document.createElement('div');
        div.className = "pool-item";
        if (state.excluded.has(key)) div.classList.add("disabled");

        div.innerHTML = `<b>${q.word}</b> <span style="color: var(--muted);">(${q.reading})</span>`;
        div.addEventListener('click', () => {
          if (state.excluded.has(key)) {
            state.excluded.delete(key);
          } else {
            state.excluded.add(key);
          }
          renderPool();
        });

        poolDiv.appendChild(div);
      });
      if (state.mode === 'learning') updateLearningGroups();
    }

    function updateLearningGroups() {
      const pool = buildPool();
      const sel = document.getElementById('learnGroup');
      sel.innerHTML = "";

      if (pool.length === 0) {
        state.learningGroups = [];
        return;
      }

      // Divide pool into groups of 4
      const groups = partitionIntoGroups(pool, 4);
      state.learningGroups = groups;

      groups.forEach((grp, i) => {
        const opt = document.createElement('option');
        opt.value = i;

        // Get all kanji (words) for this group
        const names = grp.map(w => w.word).join(', ');
        opt.textContent = `${i + 1}:　${names}`;

        sel.appendChild(opt);
      });
    }




    const toggleBtn = document.getElementById('togglePool');
    const poolTable = document.getElementById('poolTable');

    toggleBtn.addEventListener('click', () => {
      const isHidden = poolTable.style.display === "none";
      poolTable.style.display = isHidden ? "grid" : "none";
      toggleBtn.textContent = isHidden ? "Hide" : "Show";
    });
    poolTable.style.display = "none";
    poolTable.style.display = "none";
    toggleBtn.textContent = "Show"



    // Fallback demo data so the UI works out-of-the-box
    if(!window.J5){
      window.J5 = ``;
    }

    // ========= State =========
    const state = {
      level: Number(localStorage.getItem('jp.level')) || 5,
      mode: localStorage.getItem('jp.mode') || 'meaning',
      questions: Number(localStorage.getItem('jp.questions')) || 10,
      idx: 0,
      set: [], // questions array
      choices: [], // array of arrays
      answers: [], // strings
      picked: [], // indexes picked 0..3 or -1
      correct: 0,
      review: [], // indices answered wrong
      excluded: new Set(), // store disabled words (by unique key, e.g. word + reading)
      learningGroups: [],          // array of arrays of word objects
      learning: null,              // { group: [], idx: 0 } during a learning session
    };

    // ========= Utilities =========
    function sample(arr, n){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] }
      return a.slice(0, Math.max(0, Math.min(n, a.length)));
    }

    function unique(arr){ return Array.from(new Set(arr)); }

    function buildLearningSubQs(wordObj) {
      const { word, meaning, reading } = wordObj;
      const combos = [
        { from: "word", to: "meaning", q: `What is the meaning of <span class="q-word">${word}</span>?`, answer: meaning },
        { from: "word", to: "reading", q: `What is the reading of <span class="q-word">${word}</span>?`, answer: reading },
        { from: "meaning", to: "word", q: `What is the kanji for "<span class="q-word">${meaning}</span>"?`, answer: word },
        { from: "meaning", to: "reading", q: `What is the reading of "<span class="q-word">${meaning}</span>"?`, answer: reading },
        { from: "reading", to: "word", q: `What is the kanji for <span class="q-word">${reading}</span>?`, answer: word },
        { from: "reading", to: "meaning", q: `What is the meaning of <span class="q-word">${reading}</span>?`, answer: meaning },
      ];
      // randomize order
      for (let i = combos.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [combos[i], combos[j]] = [combos[j], combos[i]];
      }
      return combos;
    }

    function suffixSimilarity(a, b) {
      let i = 0;
      while (
        i < a.length &&
        i < b.length &&
        a[a.length - 1 - i] === b[b.length - 1 - i]
      ) {
        i++;
      }
      return i;
    }
    
    function buildChoices(allQ, field, answerVal) {
      // If the target field is reading:
      if (field === "reading") {
        const pool = buildPool(); // use full pool, not only questions
        // Extract unique readings except the answer
        let allReadings = Array.from(new Set(
          pool.map(q => q.reading).filter(r => r !== answerVal)
        ));

        // Sort by suffix similarity DESC
        allReadings.sort((a, b) => {
          return suffixSimilarity(b, answerVal) - suffixSimilarity(a, answerVal);
        });

        // Start choices with best matches (similar endings first)
        const distractors = allReadings.slice(0, 3); // top similar 3

        let opts = [answerVal, ...distractors];

        // If less than 4, add random others
        if (opts.length < 4) {
          const remaining = allReadings.slice(3);
          const extra = sample(remaining, 4 - opts.length);
          opts = opts.concat(extra);
        }

        // Shuffle for randomness, capped at 4
        return sample(opts, 4);
      }

      // ELSE: fallback to your old logic for 'word' and 'meaning'
      const fromSet = unique(allQ.map(q=>q[field]).filter(v=>v!==answerVal));
      let pool = sample(fromSet, 3);
      if(pool.length < 3){
        const full = unique(JN[state.level].map(q=>q[field]).filter(v=>v!==answerVal && !pool.includes(v)));
        pool = pool.concat(sample(full, 3 - pool.length));
      }
      let opts = sample([answerVal, ...pool], 4);
      if(!opts.includes(answerVal)) opts[0] = answerVal;
      return sample(opts, 4);
    }


    function setModePill(){
      const labels = { word: "Kanji", meaning: "Meaning", reading: "Reading", learning: "Study" };
      document.getElementById('modePill').textContent = `Mode: ${labels[state.mode]}`;
    }

    function partitionIntoGroups(pool, size = 4) {
      const groups = [];
      for (let i = 0; i < pool.length; i += size) {
        groups.push(pool.slice(i, i + size));
      }
      // Merge a trailing single into the previous group
      if (groups.length > 1 && groups[groups.length - 1].length === 1) {
        const last = groups.pop();
        groups[groups.length - 1] = groups[groups.length - 1].concat(last);
      }
      return groups;
    }



    // ========= Rendering =========
    const els = {
      level: document.getElementById('level'),
      num: document.getElementById('num'),
      modeSeg: document.getElementById('mode'),
      start: document.getElementById('startBtn'),
      reset: document.getElementById('resetBtn'),
      quiz: document.getElementById('quiz'),
      results: document.getElementById('results'),
      qText: document.getElementById('qText'),
      qSub: document.getElementById('qSub'),
      choices: document.getElementById('choices'),
      bar: document.getElementById('bar'),
      counter: document.getElementById('counter'),
      feedback: document.getElementById('feedback'),
      next: document.getElementById('nextBtn'),
      again: document.getElementById('againBtn'),
      review: document.getElementById('reviewBtn'),
      score: document.getElementById('score'),
      breakdown: document.getElementById('breakdown'),
      summary: document.getElementById('summary'),
      hint: document.getElementById('hint')
    };

    function syncControlsFromState(){
      els.level.value = String(state.level);
      els.num.value = String(state.questions);
      for(const b of els.modeSeg.querySelectorAll('button')){
        b.classList.toggle('active', b.dataset.mode === state.mode);
      }
      setModePill();
    }

    function storeSettings(){
      localStorage.setItem('jp.level', state.level);
      localStorage.setItem('jp.mode', state.mode);
      localStorage.setItem('jp.questions', state.questions);
    }

    function startQuiz(){
      if(!dataReady){ loadAll(); }

      const pool = buildPool();
      if (!pool.length) {
        alert("No words available. Re-enable some words in the Word Pool.");
        return;
      }

      if (state.mode === 'learning') {
        const sel = document.getElementById('learnGroup');
        const groupIndex = Number(sel.value);

        if (!state.learningGroups || !state.learningGroups.length) updateLearningGroups();
        const chosen = state.learningGroups[groupIndex] || [];
        if (!chosen.length) { alert("No words in that group!"); return; }

        els.results.classList.remove('active');
        els.quiz.classList.add('active');

        // Build full flow: each word followed by its 6 subquestions
        state.learning = {
          group: chosen,
          wordIdx: 0,
          subIdx: -1,
          subs: buildLearningSubQs(chosen[0]),
        };

        renderLearningWordIntro();
        return;
      }




      // Reset state
      state.idx = 0;
      state.correct = 0;
      state.picked = []; 
      state.review = [];
      state.set = sample(pool, state.questions); // list of words
      state.subQuestions = [];

      // Build 2 sub-questions per word based on mode
      const order = questionOrder[state.mode];  // e.g. ["reading","meaning"]
      
      state.set.forEach(wordObj => {
        order.forEach(targetField => {
          state.subQuestions.push({
            wordObj,          // reference to the base word
            target: targetField,  // what to ask for
            answered: null         // true/false later
          });
        });
      });

      els.results.classList.remove('active');
      els.quiz.classList.add('active');
      renderQuestion();
    }

    function renderQuestion(){
      const sq = state.subQuestions[state.idx];
      if(!sq) return finish();

      // Update COUNTER by word pair progress (every 2 subQs = 1 word)
      const wordIndex = Math.floor(state.idx / 2) + 1;
      els.counter.textContent = `${wordIndex} / ${state.set.length}`;

      // Update PROGRESS BAR also per word
      const progress = (wordIndex - 1) / state.set.length * 100;
      els.bar.style.width = `${progress}%`;

      setModePill();

      const q = sq.wordObj;
      const target = sq.target; // "reading", "meaning", or "word"
      
      // Display base prompt depending on mode
      let prompt = "";
      if(state.mode === "word"){
        // Showing the word, asking reading or meaning
        prompt = target === "reading"
          ? `What is the reading of <span class="q-word">${q.word}</span>?`
          : `What is the meaning of <span class="q-word">${q.word}</span>?`;
      }
      else if(state.mode === "meaning"){
        // Showing the meaning, asking word or reading
        prompt = target === "word"
          ? `What is the kanji for "<span class="q-word">${q.meaning}</span>"?`
          : `What is the reading of "<span class="q-word">${q.meaning}</span>"?`;
      }
      else if(state.mode === "reading"){
        // Showing the reading, asking word or meaning
        prompt = target === "word"
          ? `What is the kanji for <span class="q-word">${q.reading}</span>?`
          : `What is the meaning of <span class="q-word">${q.reading}</span>?`;
      }

      els.qText.innerHTML = prompt;
      els.qSub.textContent = "";

      // Build choices
      const answer = q[target];
      const choices = buildChoices(state.set, target, answer); // reuse your choice logic
      els.choices.innerHTML = '';
      els.feedback.textContent = '';
      els.feedback.className = 'feedback';
      els.next.disabled = true;

      choices.forEach((text, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice';
        btn.textContent = `${idx+1}. ${text}`;
        btn.addEventListener('click', () => choose(idx, answer, choices));
        els.choices.appendChild(btn);
      });
    }

    function renderLearningWordIntro() {
      const { group, wordIdx } = state.learning;
      const q = group[wordIdx];
      els.qText.innerHTML = `<span class="q-word">${q.word}</span>`;
      els.qSub.innerHTML = `<b>${q.reading}</b><br>${q.meaning}`;
      els.choices.innerHTML = '';
      els.feedback.textContent = '';
      els.counter.textContent = `Word ${wordIdx + 1} / ${group.length}`;
      els.bar.style.width = ((wordIdx / group.length) * 100) + '%';
      els.next.textContent = "Start Questions →";
      els.next.disabled = false;
    }

    function renderLearningQuestion() {
      const { group, wordIdx, subs, subIdx } = state.learning;
      const word = group[wordIdx];
      const sq = subs[subIdx];

      els.qText.innerHTML = sq.q;
      els.qSub.textContent = '';
      els.feedback.textContent = '';
      els.next.disabled = true;
      els.next.textContent = "Next";

      const choices = buildChoices(state.learning.group, sq.to, sq.answer);
      els.choices.innerHTML = '';

      choices.forEach((c, i) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice';
        btn.textContent = `${i + 1}. ${c}`;
        btn.addEventListener('click', () => {
          const correctIndex = choices.indexOf(sq.answer);
          const children = [...els.choices.children];
          children.forEach((b, j) => {
            if (j === correctIndex) b.classList.add('correct');
            if (j === i && j !== correctIndex) b.classList.add('wrong');
            b.disabled = true;
          });
          if (i === correctIndex) {
            els.feedback.textContent = "Correct!";
            els.feedback.className = "feedback good";
          } else {
            els.feedback.innerHTML = `Incorrect. Correct answer: <b>${sq.answer}</b>`;
            els.feedback.className = "feedback bad";
          }
          els.next.disabled = false;
        });
        els.choices.appendChild(btn);
      });

      //els.counter.textContent = `Word ${wordIdx + 1} / ${group.length} · Q${subIdx + 1}/6`;
      els.counter.textContent = `Word ${wordIdx + 1} / ${group.length}`;
    }

    function nextLearning() {
      const L = state.learning;
      if (!L) return;

      // If we just showed the intro card, start first subquestion
      if (L.subIdx === -1) {
        L.subIdx = 0;
        renderLearningQuestion();
        return;
      }

      // If we’re in the middle of 6 subquestions
      if (L.subIdx < L.subs.length - 1) {
        L.subIdx++;
        renderLearningQuestion();
        return;
      }

      // Finished all 6 for this word → next word or finish
      if (L.wordIdx < L.group.length - 1) {
        L.wordIdx++;
        L.subIdx = -1;
        L.subs = buildLearningSubQs(L.group[L.wordIdx]);
        renderLearningWordIntro();
      } else {
        finish();
        state.learning = null;
      }
    }



    function choose(index, answer, choices){
      const sq = state.subQuestions[state.idx];
      if(sq.answered !== null) return; // already answered

      const correctIndex = choices.indexOf(answer);
      const children = [...els.choices.children];

      children.forEach((btn, idx) => {
        if(idx === correctIndex) btn.classList.add('correct');
        if(idx === index && idx !== correctIndex) btn.classList.add('wrong');
        btn.disabled = true;
      });

      if(index === correctIndex){
        sq.answered = true;
        els.feedback.textContent = 'Correct!';
        els.feedback.classList.add('good');
      } else {
        sq.answered = false;
        els.feedback.innerHTML = `Incorrect. Correct answer: <b>${answer}</b>`;
        els.feedback.classList.add('bad');
      }

      els.next.disabled = false;
    }


    function next(){
      const sq = state.subQuestions[state.idx];
      if(sq.answered === null) return;

      // Check if we just finished a 2-step block
      const endOfPair = ((state.idx % 2) === 1);

      state.idx++;

      if(endOfPair){
        // Evaluate the pair
        const pairIndex = state.idx - 2; // start of the pair
        const sq1 = state.subQuestions[pairIndex];
        const sq2 = state.subQuestions[pairIndex + 1];
        const isCorrectPair = (sq1.answered && sq2.answered);

        if(isCorrectPair){
          state.correct++;
        } else {
          // Push WORD index (not subquestion index!)
          const wordIndex = Math.floor(pairIndex / 2);
          state.review.push(wordIndex);
        }
      }

      if(state.idx >= state.subQuestions.length){
        return finish();
      }

      renderQuestion();
    }


    function finish(){
      els.quiz.classList.remove('active');
      els.results.classList.add('active');

      const totalWords = state.set.length;
      const correctWords = state.correct;  // already counted per word-pair
      const pct = Math.round((correctWords / Math.max(1, totalWords)) * 100);

      els.score.textContent = `${pct}%`;
      els.breakdown.innerHTML = `
        <b>${correctWords}</b> correct out of <b>${totalWords}</b><br>
        <span class="muted">Mode: ${state.mode.toUpperCase()} · Level: N${state.level}</span>
      `;

      const wrong = totalWords - correctWords;
      els.summary.innerHTML = wrong
        ? `You missed <b>${wrong}</b>. Click <b>Review mistakes</b> to cycle through them.`
        : `✨ Nice! Flawless round. Try a different mode or level.`;
    }


    function reset(){
      state.idx = 0;
      state.set = [];
      state.subQuestions = [];
      state.picked = [];
      state.correct = 0;
      state.review = [];

      els.quiz.classList.remove('active');
      els.results.classList.remove('active');
      els.qText.textContent = 'Press Start to begin';
      els.qSub.textContent = '';
      els.choices.innerHTML = '';
      els.feedback.textContent = '';
      els.counter.textContent = '0 / 0';
      els.bar.style.width = '0%';
    }


    function reviewMistakes(){
      if (!state.review.length) {
        alert("No mistakes to review.");
        return;
      }

      // Build a mini-session from words that were wrong
      const missedWords = state.review.map(i => state.set[i]);

      state.questions = missedWords.length; 
      storeSettings();

      state.idx = 0;
      state.correct = 0;
      state.picked = [];
      state.review = [];
      state.set = missedWords;

      // Build new subQuestions for the missed words
      state.subQuestions = [];
      const order = questionOrder[state.mode];
      state.set.forEach(wordObj => {
        order.forEach(target => {
          state.subQuestions.push({
            wordObj,
            target,
            answered: null
          });
        });
      });

      els.results.classList.remove('active');
      els.quiz.classList.add('active');
      renderQuestion();
    }


    // ========= Event Wiring =========
    loadAll();
    // Initialize controls from saved state
    syncControlsFromState();
    renderPool();
    // --- Auto-show learning dropdown if "learning" mode was selected ---
    if (state.mode === 'learning') {
      const rangeRow = document.querySelector('.learning-range');
      rangeRow.style.display = 'flex';
      updateLearningGroups();
    } else {
      const rangeRow = document.querySelector('.learning-range');
      rangeRow.style.display = 'none';
    }
    
    updateLearningGroups();

    //els.level.addEventListener('change', (e)=>{ state.level = Number(e.target.value); storeSettings(); });
    els.level.addEventListener('change', (e)=>{
      state.level = Number(e.target.value);
      state.excluded.clear(); // reset for new level
      renderPool();
      if (state.mode === 'learning') updateLearningGroups();
      storeSettings();
    });
    els.num.addEventListener('change', (e)=>{ state.questions = Math.max(1, Number(e.target.value||10)); storeSettings(); });
    els.modeSeg.addEventListener('click', (e)=>{
      const btn = e.target.closest('button'); if(!btn) return;
      state.mode = btn.dataset.mode; storeSettings();

      for(const b of els.modeSeg.querySelectorAll('button'))
        b.classList.toggle('active', b===btn);

      setModePill();

      const rangeRow = document.querySelector('.learning-range');
      if (state.mode === 'learning') {
        rangeRow.style.display = 'flex';
        updateLearningGroups();
      } else {
        rangeRow.style.display = 'none';
      }
    });


    els.start.addEventListener('click', ()=>{ startQuiz(); });
    els.reset.addEventListener('click', ()=>{ reset(); });
    els.next.addEventListener('click', ()=>{
      if (state.mode === 'learning') nextLearning();
      else next();
    });

    els.again.addEventListener('click', ()=>{ startQuiz(); });
    els.review.addEventListener('click', ()=>{ reviewMistakes(); });

    // Keyboard shortcuts: 1-4 to answer, Enter to next
    window.addEventListener('keydown', (e)=>{
      if(els.quiz.classList.contains('active')){
        if(['1','2','3','4'].includes(e.key)){
          const idx = Number(e.key)-1; if(state.picked[state.idx] == null){ choose(idx); }
        } else if(e.key === 'Enter'){ if(!els.next.disabled) next(); }
      }
    });
  </script>
</body>
</html>